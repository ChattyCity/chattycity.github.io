<!DOCTYPE html>
<meta charset="utf-8">
<style>

    body {
      font: 11px sans-serif;
    }
    path.chord {
      fill-opacity: .67;
      stroke: #000;
      stroke-width: .1px;
    }
    div {
      float: left;
    }
    .circle circle {
      fill: none;
      pointer-events: all;
    }

    .overlay {
      fill: none;
      pointer-events: all;
    }

</style>
<body>

<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

var padding = 40;
var boxw = 300;

var w = window,
    d = document,
    e = d.documentElement,
    g = d.getElementsByTagName('body')[0],
    x = w.innerWidth || e.clientWidth || g.clientWidth,
    y = w.innerHeight|| e.clientHeight|| g.clientHeight;

var width2 = x - 20,
    width = (width2-boxw) / 2,
    height = y - 20,
    innerRadius = Math.min(width, height) * .40 - padding,
    outerRadius = innerRadius + 24;

var formatPercent = d3.format(".1%");

var arc = d3.svg.arc()
    .innerRadius(innerRadius)
    .outerRadius(outerRadius);

var layout = d3.layout.chord()
    .padding(.005)
    .sortSubgroups(d3.descending)
    .sortChords(d3.ascending);

var layout2 = d3.layout.chord()
    .padding(.005)
    .sortSubgroups(d3.descending)
    .sortChords(d3.ascending);

var path = d3.svg.chord()
    .radius(innerRadius);

var svgp = d3.select("body").append("div")
    //.attr("id","pos")
    //.text("positive")
  .append("svg")
    .attr("width", width2)
    .attr("height", height)
    .append("g")
    .call(d3.behavior.zoom().scaleExtent([1, 8]).on("zoom", zoom))
    .append("g");

  svgp.append("rect")
    .attr("class", "overlay")
    .attr("width", width2)
    .attr("height", height);

var svg = svgp
  .append("g")
    .attr("class", "circle")
    .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

var svg2 = svgp
  .append("g")
    .attr("class", "circle")
    .attr("transform", "translate(" + (width*3)/2 + "," + height / 2 + ")");

var city;
var matrix;
var matrix2;
var sent_matrix;
var sent_matrix2;

d3.csv("cities.csv", function(cities){
  city = cities;

  var NE = 0;
  var SE = 0;
  var SW = 0;
  var NW = 0;

  for (var i=0; i < cities.length; i++){
    if (city[i].quad == "NE") NE++;
    if (city[i].quad == "SE") SE++;
    if (city[i].quad == "SW") SW++;
    if (city[i].quad == "NW") NW++;
  };

  //NE is blue
  var NE_color = d3.scale.linear()
    .domain([0,NE+1])
    .range([d3.rgb(0,255,255),d3.rgb(0,0,64)]);

  //SE is green
  var SE_color = d3.scale.linear()
    .domain([0,SE+1])
    .range([d3.rgb(0,255,0),d3.rgb(0,64,0)]);

  //SW is orange
  var SW_color = d3.scale.linear()
    .domain([0,SW+1])
    .range([d3.rgb(255,255,0),d3.rgb(64,64,0)]);

  //NW is red
  var NW_color = d3.scale.linear()
    .domain([0,NW+1])
    .range([d3.rgb(255,0,0),d3.rgb(64,0,0)]);

  var fill = [];
  for (var i = 0; i < NE; i++){
    fill.push(NE_color(i));
  };
    for (var i = 0; i < SE; i++){
    fill.push(SE_color(i));
  };
    for (var i = 0; i < SW; i++){
    fill.push(SW_color(i));
  };
    for (var i = 0; i < NW; i++){
    fill.push(NW_color(i));
  };


d3.json("legend2.json", function(legend2){
  legend_data = legend2;
d3.json("matrix_pos.json", function(matrix_pos) {
  matrix = matrix_pos;
  d3.json("matrix_neg.json", function(matrix_neg) {
    matrix2 = matrix_neg;

    d3.json("sent_matrix_pos.json", function(sent_matrix_pos) {
      sent_matrix = sent_matrix_pos;
      d3.json("sent_matrix_neg.json", function(sent_matrix_neg) {
        sent_matrix2 = sent_matrix_neg;

// building the info boxx
  //big box
      svgp.append("rect")
      .attr("x", 2*width + 10)
      .attr("y", 10)
      .attr("width", boxw)
      .attr("height", height - 20)
      .attr("fill", "grey");

  //legend box
      svgp.append("rect")
      .attr({
        x: 2*width+10,
        y: 20,
        width: boxw,
        height: 200,
        fill: "teal"
      });
    //placeholder: US map
      svgp.append("rect")
      .attr({
        x: 2*width+20,
        y: 30,
        width: boxw*0.4,
        height: 80,
        fill: "red"
      });
    //placeholder: mini chord diagram
      svgp.append("circle")
      .attr({
        cx: width2-(boxw*0.25),
        cy: 100,
        r: boxw*0.2,
        fill: "yellow"
      });
    //placeholder: legend text
      svgp.append("rect")
      .attr({
        x: 2*width+20,
        y: 170,
        width: boxw*0.9,
        height: 40,
        fill: "white"
      });   

      legendtext = "Hover over the diagram for more details about each city. You can also zoom.";

      svgp.append("text")
      .text(legendtext)
      .attr("transform", "translate("+((2*width)+25)+",0)")
      .attr("y",180)
      .call(wrap, boxw*.8);


    var chord = layout.matrix(matrix);
    var chord2 = layout2.matrix(matrix2);

    // Add a group per neighborhood.
    var group = svg.selectAll(".group")
        .data(layout.groups)
      .enter().append("g")
        .attr("class", "group")
        .on("mouseover", fade(.05))
        .on("mouseout", fade(1));

    var group2 = svg2.selectAll(".group")
        .data(layout2.groups)
      .enter().append("g")
        .attr("class", "group")
        .on("mouseover", fade(.05))
        .on("mouseout", fade(1));

    // Add a mouseover title.
    group.append("title").text(function(d, i) {
      return city[i].name + ": " + formatPercent(d.value) + " of all positive tweets";
    });

    group2.append("title").text(function(d, i) {
      return city[i].name + ": " + formatPercent(d.value) + " of all negative tweets";
    });

    // Add the group arc.
    var groupPath = group.append("path")
        .attr("id", function(d, i) { return "group" + i; })
        .attr("d", arc)
        .style("fill", function(d, i) { return fill[i]; });

    var groupPath2 = group2.append("path")
        .attr("id", function(d, i) { return "group" + i; })
        .attr("d", arc)
        .style("fill", function(d, i) { return fill[i]; });


    // Add the chords.
    var chord = svg.selectAll(".chord")
        .data(layout.chords)
      .enter().append("path")
        .attr("class", "chord")
        .style("fill", function(d) { return fill[d.source.index]; })
        .attr("d", path)
        .style("opacity", 1);

    var chord2 = svg2.selectAll(".chord")
        .data(layout2.chords)
      .enter().append("path")
        .attr("class", "chord")
        .style("fill", function(d) { return fill[d.source.index]; })
        .attr("d", path)
        .style("opacity", 1);


    // Add a mouseover title for each chord.
    chord.append("title").text(function(d) {
      return city[d.source.index].name
          + " → " + city[d.target.index].name
          + ": " + formatPercent(d.source.value)
          + "\n"
          + "average sentiment score: " + d3.round(sent_matrix[d.source.index][d.target.index], 2);
    });

    chord2.append("title").text(function(d) {
      return city[d.source.index].name
          + " → " + city[d.target.index].name
          + ": " + formatPercent(d.source.value)
          + "\n"
          + "average sentiment score: " + d3.round(sent_matrix2[d.source.index][d.target.index], 2);
    });

var ticks = group.selectAll("g")
    .data(groupTicks)
  .enter().append("g")
    .attr("transform", function(d) {
      return "rotate(" + (d.angle * 180 / Math.PI - 90) + ")"
          + "translate(" + outerRadius + ",0)";
    });

ticks.append("line")
    .attr("x1", 1)
    .attr("y1", 0)
    .attr("x2", 5)
    .attr("y2", 0)
    .style("stroke", "#000");

ticks.append("text")
    .attr("x", 8)
    .attr("dy", ".35em")
    .attr("transform", function(d) { return d.angle > Math.PI ? "rotate(180)translate(-16)" : null; })
    .style("text-anchor", function(d) { return d.angle > Math.PI ? "end" : null; })
    .text(function(d) { return d.label; });


var ticks2 = group2.selectAll("g")
    .data(groupTicks)
  .enter().append("g")
    .attr("transform", function(d) {
      return "rotate(" + (d.angle * 180 / Math.PI - 90) + ")"
          + "translate(" + outerRadius + ",0)";
    });

ticks2.append("line")
    .attr("x1", 1)
    .attr("y1", 0)
    .attr("x2", 5)
    .attr("y2", 0)
    .style("stroke", "#000");

ticks2.append("text")
    .attr("x", 8)
    .attr("dy", ".35em")
    .attr("transform", function(d) { return d.angle > Math.PI ? "rotate(180)translate(-16)" : null; })
    .style("text-anchor", function(d) { return d.angle > Math.PI ? "end" : null; })
    .text(function(d) { return d.label; });


//svg.append("circle")
//    .attr("r", innerRadius);

//svg2.append("circle")
//    .attr("r", innerRadius);


// Returns an array of tick angles and labels, given a group.
function groupTicks(d) {
  var k = (d.endAngle - d.startAngle) / 2;
  return d3.range(1).map(function(v, i) {
    return {
      angle: k + d.startAngle,
      label: city[d.index].name
    };
  });
}

// Returns an event handler for fading a given chord group.
function fade(opacity) {
    return function(g, i) {
      console.log(legend_data[i]);
    svg.selectAll("path.chord")
        .filter(function(d) { return d.source.index != i && d.target.index != i; })
      //.transition()
        .style("opacity", opacity);

    svg2.selectAll("path.chord")
        .filter(function(d) { return d.source.index != i && d.target.index != i; })
      //.transition()
        .style("opacity", opacity);
  };
}


});
});
});
});
});
});

function zoom() {
  svgp.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
}

function wrap(text, width) {
  text.each(function() {
    var text = d3.select(this),
        words = text.text().split(/\s+/).reverse(),
        word,
        line = [],
        lineNumber = 0,
        lineHeight = 1.1, // ems
        y = text.attr("y"),
        dy = parseFloat(text.attr("dy")),
        tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", 0.17 + "em");
    while (word = words.pop()) {
      line.push(word);
      tspan.text(line.join(" "));
      if (tspan.node().getComputedTextLength() > width) {
        line.pop();
        tspan.text(line.join(" "));
        line = [word];
        tspan = text.append("tspan").attr("x", 0).attr("y", y).attr("dy", ++lineNumber * lineHeight + 0.17 + "em").text(word);
      }
    }
  });
}

</script>
