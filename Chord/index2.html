<!DOCTYPE html>
<meta charset="utf-8">
<style>

    body {
      font: 11px sans-serif;
    }

    path.chord {
      fill-opacity: .67;
      stroke: #000;
      stroke-width: .1px;
    }

    div {
      float: left;
    }

    .circle circle {
      fill: none;
      pointer-events: all;
    }

    .summary {
      visibility: hidden;
    }

    .extend_arc {
      opacity: 0;
    }

    .summary .header, .agg .header {
      font: 15px sans-serif;
    }

    .circles:hover path.fade {
      visibility: hidden;
    }

    .circles:hover g.unfade {
      visibility: visible;
    }

    .circles:hover g.aggfade {
      visibility: hidden;
    }


</style>
<body>

<script src="d3.min.js"></script>

<script>

var padding = 40;
var boxw = 300;

var w = window,
    d = document,
    e = d.documentElement,
    g = d.getElementsByTagName('body')[0],
    x = w.innerWidth || e.clientWidth || g.clientWidth,
    y = w.innerHeight|| e.clientHeight|| g.clientHeight;

var width2 = x - 20,
    width = (width2-boxw) / 2,
    height = y - 20,
    innerRadius = Math.min(width, height) * .40 - padding,
    outerRadius = innerRadius + 24;

var sumtop = 240;
var sumtext = 10;
var sumdy = 15;
var sumcityleft = sumtext+100;
var sumcitypartwidth = 90;

var formatPercent = d3.format(".1%");

var arc = d3.svg.arc()
    .innerRadius(innerRadius)
    .outerRadius(outerRadius);

var layout = d3.layout.chord()
    .padding(.005)
    .sortSubgroups(d3.descending)
    .sortChords(d3.ascending);

var layout2 = d3.layout.chord()
    .padding(.005)
    .sortSubgroups(d3.descending)
    .sortChords(d3.ascending);

var path = d3.svg.chord()
    .radius(innerRadius);

var svgp = d3.select("body").append("div").attr("id","viz")
  .append("svg")
    .attr("width", width2)
    .attr("height", height)
    .attr("class","mastersvg")
    .append("g")
    .call(d3.behavior.zoom().scaleExtent([1, 8]).on("zoom", zoom))
    .append("g")
    .attr("class","circles");

var svg = svgp
  .append("g")
    .attr("class", "circle")
    .attr("transform", "translate(" + ((width / 2)+boxw) + "," + height / 2 + ")");

var svg2 = svgp
  .append("g")
    .attr("class", "circle")
    .attr("transform", "translate(" + ((width*3)/2 + boxw) + "," + height / 2 + ")");

svg.append("circle")
  .attr("r", innerRadius);

svg2.append("circle")
  .attr("r", innerRadius);

var city;
var summary_data;
var matrix_pos;
var matrix_neg;
var sent_matrix_pos;
var sent_matrix_neg;

d3.csv("cities.csv", function(cities){
  city = cities;

  var NE = 0;
  var SE = 0;
  var SW = 0;
  var NW = 0;

  for (var i=0; i < cities.length; i++){
    if (city[i].quad == "NE") NE++;
    if (city[i].quad == "SE") SE++;
    if (city[i].quad == "SW") SW++;
    if (city[i].quad == "NW") NW++;
  };

  //NE is green
  var NE_color = d3.scale.linear()
    .domain([0,NE+1])
    .range([d3.rgb(0,255,0),d3.rgb(0,64,0)]);
    
  //SE is blue
  var SE_color = d3.scale.linear()
    .domain([0,SE+1])
    .range([d3.rgb(0,255,255),d3.rgb(0,0,64)]);

  //SW is red
  var SW_color = d3.scale.linear()
    .domain([0,SW+1])
    .range([d3.rgb(255,0,0),d3.rgb(64,0,0)]);

  //NW is yellow
  var NW_color = d3.scale.linear()
    .domain([0,NW+1])
    .range([d3.rgb(255,255,0),d3.rgb(64,64,0)]);

  var fill = [];
  for (var i = 0; i < NE; i++){
    fill.push(NE_color(i));
  };
    for (var i = 0; i < SE; i++){
    fill.push(SE_color(i));
  };
    for (var i = 0; i < SW; i++){
    fill.push(SW_color(i));
  };
    for (var i = 0; i < NW; i++){
    fill.push(NW_color(i));
  };


d3.json("summary.json", function(summary) {
  summary_data = summary;

d3.json("matrix_pos.json", function(matrix_p) {
  matrix_pos = matrix_p;

  d3.json("matrix_neg.json", function(matrix_n) {
    matrix_neg = matrix_n;

    d3.json("sent_matrix_pos.json", function(sent_matrix_p) {
      sent_matrix_pos = sent_matrix_p;

      d3.json("sent_matrix_neg.json", function(sent_matrix_n) {
        sent_matrix_neg = sent_matrix_n;

// info boxx

//title

svgp.append("text")
  .text("--Title of Chart-")
  .attr("font-size", 40)
  .attr("x", 0)
  .attr("y", 30);


  //big box
      svgp.append("rect")
      .attr("x", 0)
      .attr("y", 0)
      .attr("width", boxw)
      .attr("height", height)
      .attr("fill", "grey")
      .attr("fill-opacity",0.1);

    //map png
    svgp.append("svg:image")
       .attr("xlink:href", "USmap.png")
       .attr("width", "120px")
       .attr("height", "80px")
       .attr({
        x: 10,
        y: 40
       });


//legend diagram

    var legend_data = [
      [ 8010, 16145, 8090, 8045],
      [ 1951, 10048, 2060, 6171],
      [11975,  5871, 8916, 2868],
      [ 1013,   990,  940, 6907]
    ];

    var legend_fill = [d3.rgb(0,255,0), d3.rgb(0,100,164), d3.rgb(255,0,0), d3.rgb(255,255,0)];

    var layout3 = d3.layout.chord()
        .padding(.05)
        .sortSubgroups(d3.descending);

    var chord3 = layout3.matrix(legend_data);

    var legend_arc = d3.svg.arc()
        .innerRadius(50)
        .outerRadius(60);

    var legend_path = d3.svg.chord()
        .radius(50);

    var svg3 = svgp
      .append("g")
      .attr("class", "circle")
      .attr("transform", "translate(" + (225) + "," + 110 + ")");

    var group3 = svg3.selectAll(".group")
      .data(layout3.groups)
      .enter().append("g")
      .attr("class", "group");

    var groupPath3 = group3.append("path")
        .attr("id", function(d, i) { return "group" + i; })
        .attr("d", legend_arc)
        .style("fill", function(d, i) { return legend_fill[i]; });

    var chord3 = svg3.selectAll(".chord")
        .data(layout3.chords)
      .enter().append("path")
        .attr("class", "chord")
        .style("fill", function(d) { return legend_fill[d.target.index]; })
        .attr("d", legend_path)
        .style("opacity", 1);

// legend text

      legendtext = "Hover over the diagram for more details about each city. You can also zoom.";

      svgp.append("text")
      .text(legendtext)
      .attr("transform", "translate("+sumtext+",0)")
      .attr("y",180)
      .call(wrap, boxw-20);

    //agg text
    var agg = d3.select("g.circles").append("g")
      .attr("class","agg")
      .append("g");

      agg.append("text")
      .text("total volume: xxx tweets")
      .attr({x: sumtext, y: sumtop, class: "header"});

    // summary box
    var summary = d3.select("g.circles").selectAll(".summary")
      .data(summary_data)
      .enter()
      .append("g")
      .attr("class", "summary");

    // header
      summary.append("text")
        .text(function(d){ return d[0][0]; })
        .attr({ x: sumtext, y: sumtop, class: "header" });
    // total volume
      summary.append("text")
        .text(function(d){ return "total volume: "+ (d[0][1]+d[0][3]) + " tweets"; })
        .attr({ x: sumtext, y: sumtop + sumdy });
    // tweets about city
      summary.append("text")
        .text(function(d){ return "tweets about "+d[0][0]+": "+ d[0][1]; })
        .attr({ x: sumtext, y: sumtop + sumdy*3 });
    // breakdown
      summary.append("rect")
        .attr({ x: sumtext, y: sumtop + sumdy*3 + 6, height: 12, fill: "red" })
        .attr("width", function(d){ return d[0][2]*(boxw-20) - 1; });

      summary.append("rect")
        .attr({ y: sumtop + sumdy*3 + 6, height: 12, fill: "green" })
        .attr("x", function(d){ return sumtext + d[0][2]*(boxw-20) + 1; })
        .attr("width", function(d){ return (1-d[0][2])*(boxw-20) - 1; });
    // top 5
      summary.append("text")
        .text("top 5 cities:")
        .attr({ x: sumtext, y: sumtop + sumdy*5 });
    // city1
      for(var j = 0; j<5; j++){
        summary.append("text")
          .text(function(d){ return d[1][j][0]; })
          .attr({ x: sumtext + 10, y: sumtop + sumdy*(6+j) });

        summary.append("rect")
          .attr({ y: sumtop + sumdy*(5+j) + 6, height: 12, fill: "red" })
          .attr("x", function(d){ return summary_city(d[1][0+j][1], d[1][0+j][2], d[1][5][0])[0]; })
          .attr("width", function(d){ return summary_city(d[1][0+j][1], d[1][0+j][2], d[1][5][0])[1]; }); 

        summary.append("rect")
          .attr({ y: sumtop + sumdy*(5+j) + 6, height: 12, fill: "green" })
          .attr("x", sumcityleft+sumcitypartwidth+1)
          .attr("width", function(d){ return summary_city(d[1][0+j][1], d[1][0+j][2], d[1][5][0])[2]; });
       }
    // tweets by city
      summary.append("text")
        .text(function(d){ return "tweets by "+d[0][0]+": "+ d[0][3]; })
        .attr({ x: sumtext, y: sumtop + sumdy*12 });
    // breakdown
      summary.append("rect")
        .attr({ x: sumtext, y: sumtop + sumdy*12 + 6, height: 12, fill: "red" })
        .attr("width", function(d){ return d[0][4]*(boxw-20) - 1; });
      summary.append("rect").attr({ y: sumtop + sumdy*12 + 6, height: 12, fill: "green" })
        .attr("x", function(d){ return sumtext + d[0][4]*(boxw-20) + 1; })
        .attr("width", function(d){ return (1-d[0][4])*(boxw-20) - 1; });
    // top 5
      summary.append("text").text("top 5 cities:").attr({ x: sumtext, y: sumtop + sumdy*14 });
    // cities
      for(var j = 0; j<5; j++){
        summary.append("text")
          .text(function(d){ return d[2][j][0]; })
          .attr({ x: sumtext + 10, y: sumtop + sumdy*(15+j) });

        summary.append("rect")
          .attr({ y: sumtop + sumdy*(14+j) + 6, height: 12, fill: "red" })
          .attr("x", function(d){ return summary_city(d[2][0+j][1], d[2][0+j][2], d[2][5][0])[0]; })
          .attr("width", function(d){ return summary_city(d[2][0+j][1], d[2][0+j][2], d[2][5][0])[1]; });
        
        summary.append("rect")
          .attr({ y: sumtop + sumdy*(14+j) + 6, height: 12, fill: "green" })
          .attr("x", sumcityleft+sumcitypartwidth+1)
          .attr("width", function(d){ return summary_city(d[2][0+j][1], d[2][0+j][2], d[2][5][0])[2]; });
      }


var coverbox = d3.select(".mastersvg")
  .append("rect")
  .attr({
    x: 0, y:0, width: boxw, height: height, opacity: 0
  });


// main charts

    var chord = layout.matrix(matrix_neg);
    var chord2 = layout2.matrix(matrix_pos);

    // Add a group per neighborhood.
    var group = svg.selectAll(".group")
        .data(layout.groups)
      .enter().append("g")
        .attr("class", "group")
        .on("mouseover", fade());

    var group2 = svg2.selectAll(".group")
        .data(layout2.groups)
      .enter().append("g")
        .attr("class", "group")
        .on("mouseover", fade());

//



    // Add a mouseover title.
    group.append("title").text(function(d, i) {
      return city[i].name + ": " + formatPercent(d.value) + " of all negative tweets";
    });

    group2.append("title").text(function(d, i) {
      return city[i].name + ": " + formatPercent(d.value) + " of all positive tweets";
    });


    // Add the group arc.
    var groupPath = group.append("path")
        .attr("id", function(d, i) { return "group" + i; })
        .attr("d", arc)
        .style("fill", function(d, i) { return fill[i]; });

    var groupPath2 = group2.append("path")
        .attr("id", function(d, i) { return "group" + i; })
        .attr("d", arc)
        .style("fill", function(d, i) { return fill[i]; });


    var extend_arc = d3.svg.arc()
        .innerRadius(outerRadius)
        .outerRadius(outerRadius+50);

//proximity detenction for hover
    var groupPathExtend= group.append("path")
        .attr("class", "extend_arc")
        .attr("d", extend_arc);

    var groupPath2Extend= group2.append("path")
        .attr("class", "extend_arc")
        .attr("d", extend_arc);

    // Add the chords.
    var chord = svg.selectAll(".chord")
        .data(layout.chords)
      .enter().append("path")
        .attr("class", "chord")
        .style("fill", function(d) { return fill[d.source.index]; })
        .attr("d", path)
        .style("opacity", 1);

    var chord2 = svg2.selectAll(".chord")
        .data(layout2.chords)
      .enter().append("path")
        .attr("class", "chord")
        .style("fill", function(d) { return fill[d.source.index]; })
        .attr("d", path)
        .style("opacity", 1);


    // Add a mouseover title for each chord.
    chord.append("title").text(function(d) {
      return city[d.source.index].name
          + " → " + city[d.target.index].name
          + ": " + formatPercent(d.source.value)
          + "\n"
          + "average sentiment score: " + d3.round(sent_matrix_neg[d.source.index][d.target.index], 2);
    });

    chord2.append("title").text(function(d) {
      return city[d.source.index].name
          + " → " + city[d.target.index].name
          + ": " + formatPercent(d.source.value)
          + "\n"
          + "average sentiment score: " + d3.round(sent_matrix_pos[d.source.index][d.target.index], 2);
    });

var ticks = group.selectAll("g")
    .data(groupTicks)
  .enter().append("g")
    .attr("transform", function(d) {
      return "rotate(" + (d.angle * 180 / Math.PI - 90) + ")"
          + "translate(" + outerRadius + ",0)";
    });

ticks.append("line")
    .attr("x1", 1)
    .attr("y1", 0)
    .attr("x2", 5)
    .attr("y2", 0)
    .style("stroke", "#000");

ticks.append("text")
    .attr("x", 8)
    .attr("dy", ".35em")
    .attr("transform", function(d) { return d.angle > Math.PI ? "rotate(180)translate(-16)" : null; })
    .style("text-anchor", function(d) { return d.angle > Math.PI ? "end" : null; })
    .text(function(d) { return d.label; });


var ticks2 = group2.selectAll("g")
    .data(groupTicks)
  .enter().append("g")
    .attr("transform", function(d) {
      return "rotate(" + (d.angle * 180 / Math.PI - 90) + ")"
          + "translate(" + outerRadius + ",0)";
    });

ticks2.append("line")
    .attr("x1", 1)
    .attr("y1", 0)
    .attr("x2", 5)
    .attr("y2", 0)
    .style("stroke", "#000");

ticks2.append("text")
    .attr("x", 8)
    .attr("dy", ".35em")
    .attr("transform", function(d) { return d.angle > Math.PI ? "rotate(180)translate(-16)" : null; })
    .style("text-anchor", function(d) { return d.angle > Math.PI ? "end" : null; })
    .text(function(d) { return d.label; });


// Returns an array of tick angles and labels, given a group.
function groupTicks(d) {
  var k = (d.endAngle - d.startAngle) / 2;
  return d3.range(1).map(function(v, i) {
    return {
      angle: k + d.startAngle,
      label: city[d.index].name
    };
  });
}

// Returns an event handler for fading a given chord group.
function fade() {
    return function(g, i) {

            chord.classed("fade", function(p) { return p.source.index != i && p.target.index != i; });

            chord2.classed("fade", function(p) { return p.source.index != i && p.target.index != i; });

            summary.classed("unfade", function(d) { return d[0][0] == city[i].name; })

            agg.classed("aggfade", true);
  };
}


});
});
});
});
});
});

function zoom() {
  svgp.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
}

function wrap(text, width) {
  text.each(function() {
    var text = d3.select(this),
        words = text.text().split(/\s+/).reverse(),
        word,
        line = [],
        lineNumber = 0,
        lineHeight = 1.1, // ems
        y = text.attr("y"),
        dy = parseFloat(text.attr("dy")),
        tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", 0.17 + "em");
    while (word = words.pop()) {
      line.push(word);
      tspan.text(line.join(" "));
      if (tspan.node().getComputedTextLength() > width) {
        line.pop();
        tspan.text(line.join(" "));
        line = [word];
        tspan = text.append("tspan").attr("x", 0).attr("y", y).attr("dy", ++lineNumber * lineHeight + 0.17 + "em").text(word);
      }
    }
  });
}

function summary_city(total, neg_p, maxval) {
  var r1 = sumcityleft + (((maxval - (total*neg_p))/maxval)*sumcitypartwidth);
  var r2 = (((total*neg_p)/maxval)*sumcitypartwidth)-1;
  var r3 = (((total*(1-neg_p))/maxval)*sumcitypartwidth)-1;
  if (r2<1){
    r2 = 0
  }
  if (r2<1){
    r2 = 0
  }
  return [r1, r2, r3];
}

</script>